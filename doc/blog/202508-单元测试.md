## 概述

长时间以来, 团队很少严格要求后端单元测试的覆盖率, 某种意义上讲, 在单元测试上省下来的研发时间, 又会因产品缺陷导致整体研发时间并未真正节省

后续需要强化单元测试

## 整体目标

`SpringBoot` 单元测试往往由于需要注入过多的 初始化对象, 从而使得单元测试变得笨重, 如何设计并实现 轻量化的单元测试样例,
值得思考和学习

## 静态方法注入

比如 业务代码使用了部分静态方法, 可以使用`MockedStatic` 完成 `mock`

 ```xml

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-inline</artifactId>
    <version>5.2.0</version>
    <scope>test</scope>
</dependency>
```

```java

@Test
void testMyMethod() {
    // 使用 Mockito.mockStatic 模拟静态类 SpringUtil
    try (MockedStatic<SpringUtil> mockedStatic = Mockito.mockStatic(SpringUtil.class)) {
        // 当调用 SpringUtil.getApplicationName() 时，返回 "mock-app"
        mockedStatic.when(SpringUtil::getApplicationName).thenReturn("mock-app");
        // 验证结果
        Assertions.assertEquals("mock-app", SpringUtil.getApplicationName());
    }
}
```

### Spring Bean 注入

```java

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@ExtendWith(MockitoExtension.class)
@Slf4j
class Tests {

    @Mock
    IPatientRepository iPatientRepository;

    @Test
    @SneakyThrows
    void mock() {
        Mockito.when(iPatientRepository.findById(1L))
                .thenReturn(Optional.of(new Patient()));
        Optional<Patient> byId = iPatientRepository.findById(1L);
        Assertions.assertTrue(byId.isPresent());
    }
}

```
