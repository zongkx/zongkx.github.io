import{_ as r,c as e,o as t,a2 as o}from"./chunks/framework.BYllqQUr.js";const s="/assets/dfsfsldf.DvSncU7p.png",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"doc/blog/202506-duckdb分布式查询设计.md","filePath":"doc/blog/202506-duckdb分布式查询设计.md"}'),n={name:"doc/blog/202506-duckdb分布式查询设计.md"};function l(i,a,p,c,d,h){return t(),e("div",null,[...a[0]||(a[0]=[o('<p><img src="'+s+`" alt="img.png"></p><h2 id="整体架构" tabindex="-1">整体架构 <a class="header-anchor" href="#整体架构" aria-label="Permalink to &quot;整体架构&quot;">​</a></h2><ul><li>无主架构,数据无冗余,数据仅在当前节点写入</li><li>duckdb作为主数据源进行业务数据存储</li><li>设备海量数据本地存储(行列混合/分区)</li><li>跨节点查询</li></ul><h2 id="分布式节点设计" tabindex="-1">分布式节点设计 <a class="header-anchor" href="#分布式节点设计" aria-label="Permalink to &quot;分布式节点设计&quot;">​</a></h2><p>使用 <code>hazelcast</code>自动管理分布式节点,无主架构, embedded 服务发现</p><h2 id="分布式查询设计" tabindex="-1">分布式查询设计 <a class="header-anchor" href="#分布式查询设计" aria-label="Permalink to &quot;分布式查询设计&quot;">​</a></h2><p>如何利用Apache Calcite、Hazelcast、DuckDB及Arrow等技术，将复杂的SQL查询任务分解、下推、并行执行并最终高效响应。</p><h3 id="_1-sql解析与优化" tabindex="-1"><strong>1. SQL解析与优化</strong> <a class="header-anchor" href="#_1-sql解析与优化" aria-label="Permalink to &quot;**1\\. SQL解析与优化**&quot;">​</a></h3><p>协调器节点接收到SQL后，利用Apache Calcite进行解析和优化，生成包含计算下推和预聚合指令的分布式查询计划。</p><p><strong>示例：</strong></p><p>原始SQL：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT name, COUNT(\\*) FROM users WHERE country=&#39;JP&#39; GROUP BY name;</span></span></code></pre></div><p>经过Calcite优化后的逻辑计划：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Project(name, count)  </span></span>
<span class="line"><span>    Aggregate(group={name})  </span></span>
<span class="line"><span>        Filter(country=&#39;JP&#39;)  </span></span>
<span class="line"><span>            TableScan(users)</span></span></code></pre></div><h3 id="_2-任务分发" tabindex="-1"><strong>2. 任务分发</strong> <a class="header-anchor" href="#_2-任务分发" aria-label="Permalink to &quot;**2\\. 任务分发**&quot;">​</a></h3><p>优化后的查询计划被分解成多个子任务，通过Hazelcast的分布式通信能力，高效地分发给集群中所有工作节点（包括自身）。</p><p><strong>概念示意：</strong> 协调器向多个工作节点并行发送针对各自数据分片的查询任务。</p><h3 id="_3-局部执行与转换" tabindex="-1"><strong>3. 局部执行与转换</strong> <a class="header-anchor" href="#_3-局部执行与转换" aria-label="Permalink to &quot;**3\\. 局部执行与转换**&quot;">​</a></h3><p>每个工作节点使用DuckDB执行分配到的局部查询任务，并将结果高效地转换为内存友好的Arrow流，为网络传输做准备。</p><p>数据缩减效果：<br> 局部处理的原始数据量通常远大于预聚合后输出的Arrow流数据量。例如，每个节点可能处理1000-1200单位的原始数据，但经过DuckDB的预聚合和过滤，最终输出的Arrow流数据量可能只有60-95单位，显著减少了网络传输负担。</p><h3 id="_4-收集arrow流" tabindex="-1"><strong>4. 收集Arrow流</strong> <a class="header-anchor" href="#_4-收集arrow流" aria-label="Permalink to &quot;**4\\. 收集Arrow流**&quot;">​</a></h3><p>协调器节点从所有工作节点异步收集返回的Arrow流。这些流已经是经过预聚合和过滤的“瘦”数据。</p><p><strong>概念示意：</strong> 各个工作节点将处理完成的局部Arrow流汇聚回协调器节点。</p><h3 id="_5-合并arrow流" tabindex="-1"><strong>5. 合并Arrow流</strong> <a class="header-anchor" href="#_5-合并arrow流" aria-label="Permalink to &quot;**5\\. 合并Arrow流**&quot;">​</a></h3><p>协调器将所有接收到的Arrow流在内存中高效合并，形成一个统一的、全局的Arrow数据集，为最终查询做准备。</p><p><strong>概念示意：</strong> 多个独立的Arrow流在协调器处汇聚，形成一个完整的、单一的Arrow数据集。</p><h3 id="_6-最终查询与响应" tabindex="-1"><strong>6. 最终查询与响应</strong> <a class="header-anchor" href="#_6-最终查询与响应" aria-label="Permalink to &quot;**6\\. 最终查询与响应**&quot;">​</a></h3><p>协调器再次利用DuckDB，对合并后的全局Arrow数据集执行最终的排序、聚合和分页操作，并将最终结果返回给客户端。</p><p>数据过滤效率：<br> 在最终查询阶段，通常只有少量数据（例如总数据量的15%）是最终返回给客户端的，而大部分数据（例如85%）会在这一阶段被过滤掉，这进一步体现了整个流程的效率。</p><h2 id="核心技术栈" tabindex="-1"><strong>核心技术栈</strong> <a class="header-anchor" href="#核心技术栈" aria-label="Permalink to &quot;**核心技术栈**&quot;">​</a></h2><p>该架构的实现依赖于一系列业界领先的开源技术：</p><ul><li><strong>Apache Calcite：</strong> 动态数据管理框架，负责SQL解析、验证和优化，生成高效的查询计划。</li><li><strong>Hazelcast：</strong> 内存计算平台，用于任务分发和节点间的快速通信。</li><li><strong>DuckDB：</strong> 高性能的嵌入式分析数据库，负责局部数据的高速查询和对Arrow流的最终处理。</li><li><strong>Apache Arrow：</strong> 跨语言的列式内存数据格式，确保了节点间数据传输和处理的极致效率。</li></ul><h2 id="架构优势" tabindex="-1"><strong>架构优势</strong> <a class="header-anchor" href="#架构优势" aria-label="Permalink to &quot;**架构优势**&quot;">​</a></h2><ul><li><strong>高性能：</strong> 通过计算下推和预聚合，极大减少了网络传输的数据量。Arrow格式避免了不必要的序列化/反序列化开销。</li><li><strong>可扩展性：</strong> 无主节点架构和分布式设计，使得系统可以通过简单增加工作节点来水平扩展，应对日益增长的数据量。</li><li><strong>灵活性：</strong> 模块化的技术选型，可以连接多种异构数据源，并轻松替换或升级其中任何一个组件。</li></ul>`,34)])])}const b=r(n,[["render",l]]);export{u as __pageData,b as default};
