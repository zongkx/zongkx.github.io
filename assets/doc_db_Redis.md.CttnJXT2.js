import{_ as n,c as a,o as p,ag as e}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"Redis","description":"","frontmatter":{},"headers":[],"relativePath":"doc/db/Redis.md","filePath":"doc/db/Redis.md"}'),l={name:"doc/db/Redis.md"};function i(t,s,c,r,o,u){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h1><p>优点：</p><ol><li>读写性能优秀（基于内存、采用单线程避免了不必要的上下文切换和竞争条件、使用多路IO复用模型，非阻塞IO、数据结构简单且丰富）</li><li>支持数据持久化（AOF、RDB）</li><li>支持事务，Redis的所有操作都是原子性的，同时还支持几个操作合并后的原子性执行</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li></ol><p>缺点：</p><ol><li>受限于物理内存，不适合大量数据高性能读写，适合作为缓存，</li><li>不具备自动容错和恢复功能，存在数据不一致性的问题（主机宕机，数据未及时同步）</li></ol><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><h3 id="字符串string" tabindex="-1">字符串String <a class="header-anchor" href="#字符串string" aria-label="Permalink to &quot;字符串String&quot;">​</a></h3><p>可存储：字符串、整数或者浮点数； 操作：对整个字符串或其中一部分执行操作；对整数或浮点数自增或自减 应用：适用于简单的键值对缓存</p><blockquote><p>适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</p></blockquote><h3 id="哈希-hash" tabindex="-1">哈希 hash <a class="header-anchor" href="#哈希-hash" aria-label="Permalink to &quot;哈希 hash&quot;">​</a></h3><p>可存储：包含键值对的无序散列表 操作：添加获取移除单个键值对；获取所有键值对；检查某个键是否存在 应用：结构化的数据，比如一个对象</p><blockquote><p>一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</p></blockquote><h3 id="列表" tabindex="-1">列表 <a class="header-anchor" href="#列表" aria-label="Permalink to &quot;列表&quot;">​</a></h3><p>可存储：列表 list 操作：从两边压入或弹出元素；对单个多个元素修剪；只保留一个范围内的元素 应用：存储一些列表型的数据，类似**列表</p><blockquote></blockquote><p>因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的*** ，消息队列等。</p><h3 id="集合-set" tabindex="-1">集合 set <a class="header-anchor" href="#集合-set" aria-label="Permalink to &quot;集合 set&quot;">​</a></h3><p>可存储：无需集合 操作：添加获取移除单个元素；查找某个元素；计算交集、并集、差集；获取某个元素 应用：交集、差集、并集操作</p><blockquote><p>可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</p></blockquote><h3 id="有序集合zset" tabindex="-1">有序集合Zset <a class="header-anchor" href="#有序集合zset" aria-label="Permalink to &quot;有序集合Zset&quot;">​</a></h3><p>可存储：有序集合 操作：添加获取删除元素；根据范围获取元素排名； 应用：去重且排序</p><blockquote><p>排序</p></blockquote><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><ul><li>计数器：可以对String自增自减实现计数器功能。</li><li>缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰机制保证缓存命中率</li><li>会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性</li><li>查找表：用于获取不可靠数据的快速查询</li><li>消息队列：利用list双向链表的特性，可以通过lpush和lpop写入和读取消息，更主流的是RabbitMQ等消息中间件。</li><li>SET和ZSET：取交集、差集等操作；排序</li></ul><h2 id="持久化" tabindex="-1">持久化 <a class="header-anchor" href="#持久化" aria-label="Permalink to &quot;持久化&quot;">​</a></h2><p>将内存中的数据写入到磁盘，防止数据丢失</p><h3 id="rdb-默认" tabindex="-1">RDB（默认） <a class="header-anchor" href="#rdb-默认" aria-label="Permalink to &quot;RDB（默认）&quot;">​</a></h3><p>Redis DataBase：按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。 其缺点是：数据安全性低，RDB是间隔一段时间进行持久化，期间出现宕机导致数据丢失。</p><h3 id="aof" tabindex="-1">AOF <a class="header-anchor" href="#aof" aria-label="Permalink to &quot;AOF&quot;">​</a></h3><p>Append Only File：Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 优点：</p><ol><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ol><p>缺点:</p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li></ol><h2 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h2><p>原子性:事务中的操作要么都发生，要么都不发生 一致性：事务执行前后数据完整性一致 隔离性：并发执行的互不影响 持久性：事务一旦提交，数据就永久被修改 Redis事务总是保证一致性和隔离性。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。</p><h2 id="集群" tabindex="-1">集群 <a class="header-anchor" href="#集群" aria-label="Permalink to &quot;集群&quot;">​</a></h2><h3 id="哨兵模式" tabindex="-1">哨兵模式 <a class="header-anchor" href="#哨兵模式" aria-label="Permalink to &quot;哨兵模式&quot;">​</a></h3><p>哨兵是redis集群中非常重要的一个组件，负责</p><ul><li>集群监控：负责监控redis master和slvae进程</li><li>消息通知：如果某个redis实例有故障，通知管理员</li><li>故障转移：如果master node宕机，会自动转移到slave node</li><li>配置中心：如果故障转移了，通知client客户端新的master地址 （至少需要3个哨兵；不保证数据零丢失，保证高可用）</li></ul><h3 id="主从架构" tabindex="-1">主从架构 <a class="header-anchor" href="#主从架构" aria-label="Permalink to &quot;主从架构&quot;">​</a></h3><p>maternode负责数据写入，写入之后复制到若干个slavenode，读操作都从从节点取数据。（读写分离）</p><h2 id="springboot-demo" tabindex="-1">SpringBoot Demo <a class="header-anchor" href="#springboot-demo" aria-label="Permalink to &quot;SpringBoot Demo&quot;">​</a></h2><h3 id="依赖和配置" tabindex="-1">依赖和配置 <a class="header-anchor" href="#依赖和配置" aria-label="Permalink to &quot;依赖和配置&quot;">​</a></h3><p>SpringBoot常用的Redis客户端如Jedis\\Lettuce，SpringBoot2.0之后已经默认使用Lettuce，</p><blockquote><p>Lettuce的连接是基于Netty的，连接实例可以在多个线程间共享，如果你不知道Netty也没事，大致意思就是一个多线程的应用可以使用同一个连接实例，而不用担心并发线程的数量。通过异步的方式可以让我们更好地利用系统资源。 Jedis 是直连模式，在多个线程间共享一个 Jedis 实例时是线程不安全的，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，物理连接成本就较高了。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>        &lt;dependency&gt;</span></span>
<span class="line"><span>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;/dependency&gt;</span></span></code></pre></div><p>配置:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>spring.cache.type=Redis</span></span>
<span class="line"><span>spring.redis.host=127.0.0.1</span></span>
<span class="line"><span>spring.redis.port=6379</span></span>
<span class="line"><span>spring.redis.lettuce.pool.max-active=8</span></span>
<span class="line"><span>spring.redis.lettuce.pool.max-idle=8</span></span>
<span class="line"><span>spring.redis.lettuce.pool.min-idle=0</span></span>
<span class="line"><span># 如果配置了pool,那么必须加入commons-pool2的依赖</span></span>
<span class="line"><span>        &lt;!-- redis依赖commons-pool --&gt;</span></span>
<span class="line"><span>        &lt;dependency&gt;</span></span>
<span class="line"><span>            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span></span>
<span class="line"><span>            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;/dependency&gt;</span></span></code></pre></div><h3 id="redistemplate" tabindex="-1">RedisTemplate <a class="header-anchor" href="#redistemplate" aria-label="Permalink to &quot;RedisTemplate&quot;">​</a></h3><p>在配置完之后就可以通过注入RedisTemplate来使用了,不过RedisTemplate默认只支持&lt;String,String&gt; 形式的，为了能够扩展，可以手动添加bean来实现。（Spring-Cache也可以使用Redis，在某种情况下，如果可以手动读写缓存也可以不使用@Cache等注解） 下面是自定义bean</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public RedisSerializer&lt;Object&gt; redisSerializer() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        ObjectMapper objectMapper = new ObjectMapper();</span></span>
<span class="line"><span>        //反序列化时候遇到不匹配的属性并不抛出异常</span></span>
<span class="line"><span>        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span></span>
<span class="line"><span>        //序列化时候遇到空对象不抛出异常</span></span>
<span class="line"><span>        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);</span></span>
<span class="line"><span>        //反序列化的时候如果是无效子类型,不抛出异常</span></span>
<span class="line"><span>        objectMapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);</span></span>
<span class="line"><span>        //不使用默认的dateTime进行序列化,</span></span>
<span class="line"><span>        objectMapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, false);</span></span>
<span class="line"><span>        //使用JSR310提供的序列化类,里面包含了大量的JDK8时间序列化类</span></span>
<span class="line"><span>        objectMapper.registerModule(new JavaTimeModule());</span></span>
<span class="line"><span>        //启用反序列化所需的类型信息,在属性中添加@class</span></span>
<span class="line"><span>        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span></span>
<span class="line"><span>        //配置null值的序列化器</span></span>
<span class="line"><span>        GenericJackson2JsonRedisSerializer.registerNullValueSerializer(objectMapper, null);</span></span>
<span class="line"><span>        return new GenericJackson2JsonRedisSerializer(objectMapper);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Bean(name = &quot;redisTemplate&quot;)</span></span>
<span class="line"><span>    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory, RedisSerializer&lt;Object&gt; redisSerializer) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();</span></span>
<span class="line"><span>        template.setConnectionFactory(redisConnectionFactory);</span></span>
<span class="line"><span>        template.setDefaultSerializer(redisSerializer);</span></span>
<span class="line"><span>        template.setValueSerializer(redisSerializer);</span></span>
<span class="line"><span>        template.setHashValueSerializer(redisSerializer);</span></span>
<span class="line"><span>        template.setKeySerializer(StringRedisSerializer.UTF_8);</span></span>
<span class="line"><span>        template.setHashKeySerializer(StringRedisSerializer.UTF_8);</span></span>
<span class="line"><span>        template.afterPropertiesSet();</span></span>
<span class="line"><span>        return template;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span> /**</span></span>
<span class="line"><span>     * 对hash类型的数据操作</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param redisTemplate</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate redisTemplate) {</span></span>
<span class="line"><span>        return redisTemplate.opsForHash();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 对redis字符串类型数据操作</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param redisTemplate</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate redisTemplate) {</span></span>
<span class="line"><span>        return redisTemplate.opsForValue();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 对链表类型的数据操作</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param redisTemplate</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate redisTemplate) {</span></span>
<span class="line"><span>        return redisTemplate.opsForList();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 对无序集合类型的数据操作</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param redisTemplate</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate redisTemplate) {</span></span>
<span class="line"><span>        return redisTemplate.opsForSet();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 对有序集合类型的数据操作</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param redisTemplate</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate redisTemplate) {</span></span>
<span class="line"><span>        return redisTemplate.opsForZSet();</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>在网上搜到的大部分RedisTemplate中用的都是Jackson2JsonRedisSerializer,其中的enableDefaultTyping还是一个过期的方法,找到了使用GenericJackson2JsonRedisSerializer的原因:</p><blockquote><ol><li>无参构造调用一个参数的构造</li><li>构造中创建ObjectMapper,并且设置了一个NullValueSerializer</li><li>ObjectMapper设置包含类信息 上面的RedisTemplate redisTemplate作为参数,如果直接用RedisTemplate&lt;String,Object&gt; redisTemplate 在IDEA中会报不能注入bean的错误,只需要把k,v</li></ol></blockquote><p>对于JDK1.8中的LocalDate和LocalDateTime，可能会出现</p><blockquote><p>Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of <code>java.time.LocalDateTime</code> (no Creators, like default construct, exist): cannot deserialize from Object value (no delegate- or property-based Creator)</p></blockquote><p>这是由于LocalDateTime没空构造,无法反射进行构造,所以会抛出异常.(如果自定义的对象没有提供默认构造,也会抛出这个异常) 可以在该属性上添加注解</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@JsonDeserialize(using = LocalDateTimeDeserializer.class)</span></span>
<span class="line"><span>@JsonSerialize(using = LocalDateTimeSerializer.class)</span></span>
<span class="line"><span>private LocalDateTime createTime;</span></span></code></pre></div><h3 id="redisutil" tabindex="-1">RedisUtil <a class="header-anchor" href="#redisutil" aria-label="Permalink to &quot;RedisUtil&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>package com.demo.Util;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.springframework.data.redis.core.BoundListOperations;</span></span>
<span class="line"><span>import org.springframework.data.redis.core.RedisTemplate;</span></span>
<span class="line"><span>import org.springframework.stereotype.Component;</span></span>
<span class="line"><span>import org.springframework.util.CollectionUtils;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import javax.annotation.Resource;</span></span>
<span class="line"><span>import java.util.List;</span></span>
<span class="line"><span>import java.util.Map;</span></span>
<span class="line"><span>import java.util.Set;</span></span>
<span class="line"><span>import java.util.concurrent.TimeUnit;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * redisTemplate封装</span></span>
<span class="line"><span> *</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@Component</span></span>
<span class="line"><span>public class RedisUtils {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 指定缓存失效时间</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param time 时间(秒)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean expire(String key,long time){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if(time&gt;0){</span></span>
<span class="line"><span>                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 根据key 获取过期时间</span></span>
<span class="line"><span>     * @param key 键 不能为null</span></span>
<span class="line"><span>     * @return 时间(秒) 返回0代表为永久有效</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long getExpire(String key){</span></span>
<span class="line"><span>        return redisTemplate.getExpire(key,TimeUnit.SECONDS);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 判断key是否存在</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @return true 存在 false不存在</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean hasKey(String key){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.hasKey(key);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 删除缓存</span></span>
<span class="line"><span>     * @param key 可以传一个值 或多个</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @SuppressWarnings(&quot;unchecked&quot;)</span></span>
<span class="line"><span>    public void del(String ... key){</span></span>
<span class="line"><span>        if(key!=null&amp;&amp;key.length&gt;0){</span></span>
<span class="line"><span>            if(key.length==1){</span></span>
<span class="line"><span>                redisTemplate.delete(key[0]);</span></span>
<span class="line"><span>            }else{</span></span>
<span class="line"><span>                redisTemplate.delete(CollectionUtils.arrayToList(key));</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //============================String=============================</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 普通缓存获取</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @return 值</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Object get(String key){</span></span>
<span class="line"><span>        return key==null?null:redisTemplate.opsForValue().get(key);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 普通缓存放入</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return true成功 false失败</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean set(String key,Object value) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForValue().set(key, value);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 普通缓存放入并设置时间</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span>
<span class="line"><span>     * @return true成功 false 失败</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean set(String key,Object value,long time){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if(time&gt;0){</span></span>
<span class="line"><span>                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span></span>
<span class="line"><span>            }else{</span></span>
<span class="line"><span>                set(key, value);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 递增</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param delta 要增加几(大于0)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long incr(String key, long delta){</span></span>
<span class="line"><span>        if(delta&lt;0){</span></span>
<span class="line"><span>            throw new RuntimeException(&quot;递增因子必须大于0&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return redisTemplate.opsForValue().increment(key, delta);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 递减</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param delta 要减少几(小于0)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long decr(String key, long delta){</span></span>
<span class="line"><span>        if(delta&lt;0){</span></span>
<span class="line"><span>            throw new RuntimeException(&quot;递减因子必须大于0&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return redisTemplate.opsForValue().increment(key, -delta);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //================================Map=================================</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * HashGet</span></span>
<span class="line"><span>     * @param key 键 不能为null</span></span>
<span class="line"><span>     * @param item 项 不能为null</span></span>
<span class="line"><span>     * @return 值</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Object hget(String key,String item){</span></span>
<span class="line"><span>        return redisTemplate.opsForHash().get(key, item);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 获取hashKey对应的所有键值</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @return 对应的多个键值</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Map&lt;Object,Object&gt; hmget(String key){</span></span>
<span class="line"><span>        return redisTemplate.opsForHash().entries(key);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * HashSet</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param map 对应多个键值</span></span>
<span class="line"><span>     * @return true 成功 false 失败</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean hmset(String key, Map&lt;String,Object&gt; map){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForHash().putAll(key, map);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * HashSet 并设置时间</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param map 对应多个键值</span></span>
<span class="line"><span>     * @param time 时间(秒)</span></span>
<span class="line"><span>     * @return true成功 false失败</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForHash().putAll(key, map);</span></span>
<span class="line"><span>            if(time&gt;0){</span></span>
<span class="line"><span>                expire(key, time);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 向一张hash表中放入数据,如果不存在将创建</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param item 项</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return true 成功 false失败</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean hset(String key,String item,Object value) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForHash().put(key, item, value);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 向一张hash表中放入数据,如果不存在将创建</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param item 项</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @param time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span>
<span class="line"><span>     * @return true 成功 false失败</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean hset(String key,String item,Object value,long time) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForHash().put(key, item, value);</span></span>
<span class="line"><span>            if(time&gt;0){</span></span>
<span class="line"><span>                expire(key, time);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 删除hash表中的值</span></span>
<span class="line"><span>     * @param key 键 不能为null</span></span>
<span class="line"><span>     * @param item 项 可以使多个 不能为null</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public void hdel(String key, Object... item){</span></span>
<span class="line"><span>        redisTemplate.opsForHash().delete(key,item);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 判断hash表中是否有该项的值</span></span>
<span class="line"><span>     * @param key 键 不能为null</span></span>
<span class="line"><span>     * @param item 项 不能为null</span></span>
<span class="line"><span>     * @return true 存在 false不存在</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean hHasKey(String key, String item){</span></span>
<span class="line"><span>        return redisTemplate.opsForHash().hasKey(key, item);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param item 项</span></span>
<span class="line"><span>     * @param by 要增加几(大于0)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public double hincr(String key, String item,double by){</span></span>
<span class="line"><span>        return redisTemplate.opsForHash().increment(key, item, by);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * hash递减</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param item 项</span></span>
<span class="line"><span>     * @param by 要减少记(小于0)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public double hdecr(String key, String item,double by){</span></span>
<span class="line"><span>        return redisTemplate.opsForHash().increment(key, item,-by);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //============================set=============================</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 根据key获取Set中的所有值</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Set&lt;Object&gt; sGet(String key){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForSet().members(key);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return null;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 根据value从一个set中查询,是否存在</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return true 存在 false不存在</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean sHasKey(String key,Object value){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForSet().isMember(key, value);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 将数据放入set缓存</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param values 值 可以是多个</span></span>
<span class="line"><span>     * @return 成功个数</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long sSet(String key, Object...values) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForSet().add(key, values);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 将set数据放入缓存</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param time 时间(秒)</span></span>
<span class="line"><span>     * @param values 值 可以是多个</span></span>
<span class="line"><span>     * @return 成功个数</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long sSetAndTime(String key,long time,Object...values) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Long count = redisTemplate.opsForSet().add(key, values);</span></span>
<span class="line"><span>            if(time&gt;0) {</span></span>
<span class="line"><span>                expire(key, time);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return count;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 获取set缓存的长度</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long sGetSetSize(String key){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForSet().size(key);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 移除值为value的</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param values 值 可以是多个</span></span>
<span class="line"><span>     * @return 移除的个数</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long setRemove(String key, Object ...values) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Long count = redisTemplate.opsForSet().remove(key, values);</span></span>
<span class="line"><span>            return count;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    //===============================list=================================</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 获取list缓存的内容</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param start 开始</span></span>
<span class="line"><span>     * @param end 结束  0 到 -1代表所有值</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public List&lt;Object&gt; lGet(String key, long start, long end){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForList().range(key, start, end);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return null;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 获取list缓存的长度</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long lGetListSize(String key){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForList().size(key);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 通过索引 获取list中的值</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Object lGetIndex(String key,long index){</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            return redisTemplate.opsForList().index(key, index);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return null;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 将list放入缓存</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean lSet(String key, Object value) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForList().rightPush(key, value);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 将list放入缓存</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @param time 时间(秒)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean lSet(String key, Object value, long time) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForList().rightPush(key, value);</span></span>
<span class="line"><span>            if (time &gt; 0) {</span></span>
<span class="line"><span>                expire(key, time);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 将list放入缓存</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean lSet(String key, List&lt;Object&gt; value) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForList().rightPushAll(key, value);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 将list放入缓存</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @param time 时间(秒)</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean lSet(String key, List&lt;Object&gt; value, long time) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForList().rightPushAll(key, value);</span></span>
<span class="line"><span>            if (time &gt; 0) {</span></span>
<span class="line"><span>                expire(key, time);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 根据索引修改list中的某条数据</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param index 索引</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean lUpdateIndex(String key, long index,Object value) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            redisTemplate.opsForList().set(key, index, value);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 移除N个值为value</span></span>
<span class="line"><span>     * @param key 键</span></span>
<span class="line"><span>     * @param count 移除多少个</span></span>
<span class="line"><span>     * @param value 值</span></span>
<span class="line"><span>     * @return 移除的个数</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public long lRemove(String key,long count,Object value) {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Long remove = redisTemplate.opsForList().remove(key, count, value);</span></span>
<span class="line"><span>            return remove;</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 模糊查询获取key值</span></span>
<span class="line"><span>     * @param pattern</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Set keys(String pattern){</span></span>
<span class="line"><span>        return redisTemplate.keys(pattern);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 使用Redis的消息队列</span></span>
<span class="line"><span>     * @param channel</span></span>
<span class="line"><span>     * @param message 消息内容</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public void convertAndSend(String channel, Object message){</span></span>
<span class="line"><span>        redisTemplate.convertAndSend(channel,message);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>     /**</span></span>
<span class="line"><span>     * 根据起始结束序号遍历Redis中的list</span></span>
<span class="line"><span>     * @param listKey</span></span>
<span class="line"><span>     * @param start  起始序号</span></span>
<span class="line"><span>     * @param end  结束序号</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public List&lt;Object&gt; rangeList(String listKey, long start, long end) {</span></span>
<span class="line"><span>        //绑定操作</span></span>
<span class="line"><span>        BoundListOperations&lt;String, Object&gt; boundValueOperations = redisTemplate.boundListOps(listKey);</span></span>
<span class="line"><span>        //查询数据</span></span>
<span class="line"><span>        return boundValueOperations.range(start, end);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 弹出右边的值 --- 并且移除这个值</span></span>
<span class="line"><span>     * @param listKey</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Object rifhtPop(String listKey){</span></span>
<span class="line"><span>        //绑定操作</span></span>
<span class="line"><span>        BoundListOperations&lt;String, Object&gt; boundValueOperations = redisTemplate.boundListOps(listKey);</span></span>
<span class="line"><span>        return boundValueOperations.rightPop();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //=========BoundListOperations 用法 End============</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="测试" tabindex="-1">测试 <a class="header-anchor" href="#测试" aria-label="Permalink to &quot;测试&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisUtils redisUtils;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    void contextLoads() {</span></span>
<span class="line"><span>        User user = new User();</span></span>
<span class="line"><span>        user.setId(1l);</span></span>
<span class="line"><span>        user.setTime(LocalDateTime.now());</span></span>
<span class="line"><span>        user.setPassword(&quot;xxx&quot;);</span></span>
<span class="line"><span>        redisUtils.lSet(&quot;test&quot;,user);</span></span>
<span class="line"><span>        redisUtils.set(&quot;user&quot;,user);</span></span>
<span class="line"><span>        log.info(redisUtils.get(&quot;user&quot;).toString());</span></span>
<span class="line"><span>        List&lt;Object&gt; list = redisUtils.lGet(&quot;test&quot;,0L,-1L);</span></span>
<span class="line"><span>        list.forEach(System.out::print);</span></span>
<span class="line"><span>    }</span></span></code></pre></div><h2 id="springboot-应用" tabindex="-1">SpringBoot 应用 <a class="header-anchor" href="#springboot-应用" aria-label="Permalink to &quot;SpringBoot 应用&quot;">​</a></h2><h3 id="token鉴权" tabindex="-1">Token鉴权 <a class="header-anchor" href="#token鉴权" aria-label="Permalink to &quot;Token鉴权&quot;">​</a></h3><ol><li>用户登录请求登录接口时，验证用户名密码等，验证成功会返回给前端一个token，这个token就是之后鉴权的唯一凭证。</li><li>后台可能将token存储在redis或者数据库中。</li><li>之后前端的请求，需要在header中携带token，后端取出token去redis或者数据库中进行验证，如果验证通过则放行，如果不通过则拒绝操作。</li></ol><p>下面用Redis作为缓存保存token，通过mvc拦截器来实现对登录的验证。</p><h3 id="redisservice-loginservice" tabindex="-1">RedisService/LoginService <a class="header-anchor" href="#redisservice-loginservice" aria-label="Permalink to &quot;RedisService/LoginService&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisUtils redisUtils;</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void setToken(String key, Object value) {</span></span>
<span class="line"><span>        redisUtils.set(key,value);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public Object getToken(String key) {</span></span>
<span class="line"><span>        return redisUtils.get(key);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean deleteToken(String key) {</span></span>
<span class="line"><span>        redisUtils.del(key);</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisService redisService;</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public String login(String username, String password) {</span></span>
<span class="line"><span>        if (Objects.equals(&quot;test&quot;, username) &amp;&amp; Objects.equals(&quot;123&quot;, password)) {//测试</span></span>
<span class="line"><span>            String token = UUID.randomUUID().toString();</span></span>
<span class="line"><span>            redisService.setToken(token, username);</span></span>
<span class="line"><span>            return &quot;用户：&quot; + username + &quot;登录成功，token是：&quot; + token;</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            return &quot;用户名或密码错误，登录失败！&quot;;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public String logout(HttpServletRequest request) {</span></span>
<span class="line"><span>        String token = request.getHeader(&quot;token&quot;);</span></span>
<span class="line"><span>        Boolean delete = redisService.deleteToken(token);</span></span>
<span class="line"><span>        if (!delete) {</span></span>
<span class="line"><span>            return &quot;注销失败，请检查是否登录！&quot;;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return &quot;注销成功！&quot;;</span></span>
<span class="line"><span>    }</span></span></code></pre></div><h3 id="拦截器和配置" tabindex="-1">拦截器和配置 <a class="header-anchor" href="#拦截器和配置" aria-label="Permalink to &quot;拦截器和配置&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Resource</span></span>
<span class="line"><span>    MyInterceptor myInterceptor;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void addInterceptors(InterceptorRegistry registry) {</span></span>
<span class="line"><span>        registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;)</span></span>
<span class="line"><span>                .excludePathPatterns(&quot;/toLogin&quot;,&quot;/login&quot;,&quot;/js/**&quot;,&quot;/css/**&quot;,&quot;/images/**&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>@Component</span></span>
<span class="line"><span>@Slf4j</span></span>
<span class="line"><span>public class MyInterceptor implements HandlerInterceptor {</span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private RedisService redisService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException {</span></span>
<span class="line"><span>        log.info(&quot;请求路径：{}&quot;, request.getRequestURI());</span></span>
<span class="line"><span>        response.setCharacterEncoding(&quot;UTF-8&quot;);</span></span>
<span class="line"><span>        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span></span>
<span class="line"><span>        String token = request.getHeader(&quot;token&quot;);</span></span>
<span class="line"><span>        if (StringUtils.isEmpty(token)) {</span></span>
<span class="line"><span>            response.getWriter().print(&quot;用户未登录，请登录后操作！&quot;);</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Object loginStatus = redisService.getToken(token);</span></span>
<span class="line"><span>        if( Objects.isNull(loginStatus)){</span></span>
<span class="line"><span>            response.getWriter().print(&quot;token错误，请查看！&quot;);</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="接口和测试" tabindex="-1">接口和测试 <a class="header-anchor" href="#接口和测试" aria-label="Permalink to &quot;接口和测试&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private UserService userService;</span></span>
<span class="line"><span>    @GetMapping(&quot;/login&quot;)</span></span>
<span class="line"><span>    public String login(String username,String password){</span></span>
<span class="line"><span>        return userService.login(username,password);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @GetMapping(&quot;/logout&quot;)</span></span>
<span class="line"><span>    public String logout(HttpServletRequest request){</span></span>
<span class="line"><span>        return userService.logout(request);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @GetMapping(&quot;/test&quot;)</span></span>
<span class="line"><span>    public String test(HttpServletRequest request){</span></span>
<span class="line"><span>        return &quot;ok&quot;;</span></span>
<span class="line"><span>    }</span></span></code></pre></div><blockquote><p><a href="http://localhost:8080/login?username=test&amp;password=123" target="_blank" rel="noreferrer">http://localhost:8080/login?username=test&amp;password=123</a> 用户：test登录成功，token是：564aa232-a015-481e-94f3-8a0174b11932</p></blockquote><blockquote><p>GET /test HTTP/1.1 token: 564aa232-a015-481e-94f3-8a0174b11932 Host: localhost:8080 ok</p></blockquote><blockquote><p>GET /logout HTTP/1.1 token: 564aa232-a015-481e-94f3-8a0174b11932 Host: localhost:8080 注销成功</p></blockquote><h3 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-label="Permalink to &quot;拓展&quot;">​</a></h3><ul><li>基于Token可以实现简单的单点登录,将token放到cookie中</li><li>redis的value可以适当存储用户的信息</li><li>token的生成规则可以适当复杂</li><li>拦截器可以自定义拦截特定的token</li><li>jwt扩展,后续会用.</li></ul><h1 id="redission" tabindex="-1">Redission <a class="header-anchor" href="#redission" aria-label="Permalink to &quot;Redission&quot;">​</a></h1><h2 id="分布式存在的并发问题" tabindex="-1">分布式存在的并发问题 <a class="header-anchor" href="#分布式存在的并发问题" aria-label="Permalink to &quot;分布式存在的并发问题&quot;">​</a></h2><h2 id="问题模拟" tabindex="-1">问题模拟 <a class="header-anchor" href="#问题模拟" aria-label="Permalink to &quot;问题模拟&quot;">​</a></h2><p>商品购买,在单机时并发问题可以通过synchronized, 但是在分布式情况下,JVM级别的锁不会生效.</p><p>假设: redis存了个string [stock:200]</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@GetMapping(&quot;/buy&quot;)</span></span>
<span class="line"><span>public String buy(){</span></span>
<span class="line"><span>    synchronized (this){</span></span>
<span class="line"><span>        String s = redisUtils.get(&quot;stock&quot;).toString();</span></span>
<span class="line"><span>        Integer i = Integer.parseInt(s);</span></span>
<span class="line"><span>        if(i&gt;0){</span></span>
<span class="line"><span>            int real = i-1;</span></span>
<span class="line"><span>            redisUtils.set(&quot;stock&quot;,real+&quot;&quot;);</span></span>
<span class="line"><span>            logger.info(&quot;购买成功,剩余:&quot;+real);</span></span>
<span class="line"><span>        }else{</span></span>
<span class="line"><span>            logger.info(&quot;购买失败&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return &quot;buy end&quot;;</span></span>
<span class="line"><span>}</span></span></code></pre></div><ol><li>启动两个服务product 8081/8082,并使用Nginx做负载均衡</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> # 待选服务器列表</span></span>
<span class="line"><span>   worker_processes  1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   events {</span></span>
<span class="line"><span>   worker_connections  1024;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>   http {</span></span>
<span class="line"><span>   upstream  my-server {</span></span>
<span class="line"><span>   server    localhost:8081 weight=1;</span></span>
<span class="line"><span>   server    localhost:8082 weight=1;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   server {</span></span>
<span class="line"><span>   listen       80;</span></span>
<span class="line"><span>   server_name  localhost;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   location / {</span></span>
<span class="line"><span>   proxy_pass http://my-server;</span></span>
<span class="line"><span>   proxy_redirect default;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><ol><li>使用jmeter进行压力测试</li></ol><blockquote><p><a href="http://127.0.0.1/buy" target="_blank" rel="noreferrer">http://127.0.0.1/buy</a></p></blockquote><p>可以看到后台打印的剩余库存出现了同样的数字.</p><h2 id="解决" tabindex="-1">解决 <a class="header-anchor" href="#解决" aria-label="Permalink to &quot;解决&quot;">​</a></h2><h3 id="入门级-setnx-set-if-not-exists" tabindex="-1">入门级 setnx (set if not exists) <a class="header-anchor" href="#入门级-setnx-set-if-not-exists" aria-label="Permalink to &quot;入门级 setnx (set if not exists)&quot;">​</a></h3><p>setnx key value 将key的值设为value,当且仅当key不存在</p><p>利用redis单线程模型,若干线程同时执行setnx,会进入队列.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @GetMapping(&quot;/buy2&quot;)</span></span>
<span class="line"><span>    public String buy2() {</span></span>
<span class="line"><span>        String lockKey = &quot;product_01&quot;;</span></span>
<span class="line"><span>        // setIfAbsent原子命令</span></span>
<span class="line"><span>        Boolean result = redisTemplate.opsForValue().setIfAbsent(lockKey, &quot;zong&quot;,10,TimeUnit.SECONDS);//同时设置过期时间</span></span>
<span class="line"><span>        if (!result) {</span></span>
<span class="line"><span>            return &quot;error&quot;;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Integer i = Integer.parseInt(redisUtils.get(&quot;stock&quot;).toString());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            if (i &gt; 0) {</span></span>
<span class="line"><span>                int real = i - 1;</span></span>
<span class="line"><span>                redisUtils.set(&quot;stock&quot;, real + &quot;&quot;);</span></span>
<span class="line"><span>                logger.info(&quot;购买成功,剩余:&quot; + real);</span></span>
<span class="line"><span>            } else {</span></span>
<span class="line"><span>                logger.info(&quot;购买失败&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            redisTemplate.delete(lockKey);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return &quot;buy end&quot;;</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>高并发仍然存在的问题: 锁永久失效:假设线程1try后面的代码执行时间超过了锁的过期时间,此时线程2进入并加锁,但线程1会执行到释放锁的地方, 导致线程1删除了线程2的锁.</p><h3 id="优化-添加锁需要原子操作-每个线程加的锁的value都设为uuid-释放锁的时候进行判断" tabindex="-1">优化:(添加锁需要原子操作)每个线程加的锁的value都设为UUID,释放锁的时候进行判断 <a class="header-anchor" href="#优化-添加锁需要原子操作-每个线程加的锁的value都设为uuid-释放锁的时候进行判断" aria-label="Permalink to &quot;优化:(添加锁需要原子操作)每个线程加的锁的value都设为UUID,释放锁的时候进行判断&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    String id  = UUID.randomUUID().toString();</span></span>
<span class="line"><span>    // setIfAbsent原子命令</span></span>
<span class="line"><span>    Boolean result = redisTemplate.opsForValue().setIfAbsent(lockKey, id,10,TimeUnit.SECONDS);//同时设置过期时间</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>    if (id.equals(redisTemplate.opsForValue().get(lockKey))){</span></span>
<span class="line"><span>        redisTemplate.delete(lockKey);</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>仍然存在的问题:线程1在判断成功进入的那一瞬间(还没有执行锁的释放), 锁过期了,线程2又刚加了锁,仍然导致线程1释放了线程2的锁</p><h3 id="解决-锁续命-删除锁也需要原子操作" tabindex="-1">解决:锁续命(删除锁也需要原子操作) <a class="header-anchor" href="#解决-锁续命-删除锁也需要原子操作" aria-label="Permalink to &quot;解决:锁续命(删除锁也需要原子操作)&quot;">​</a></h3><p>再开一个定时任务,判断主线程的锁是否还持有该锁,若锁过期且主线程还没结束,就刷新锁的过期时间. 使用分布式锁框架解决该问题.</p><h3 id="redission-1" tabindex="-1">Redission <a class="header-anchor" href="#redission-1" aria-label="Permalink to &quot;Redission&quot;">​</a></h3><h4 id="依赖" tabindex="-1">依赖 <a class="header-anchor" href="#依赖" aria-label="Permalink to &quot;依赖&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    &lt;dependency&gt;</span></span>
<span class="line"><span>        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span></span>
<span class="line"><span>        &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;version&gt;3.6.5&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;/dependency&gt;</span></span></code></pre></div><h4 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public Redisson redisson(){</span></span>
<span class="line"><span>        //单机模式</span></span>
<span class="line"><span>        Config config = new Config();</span></span>
<span class="line"><span>        config.useSingleServer().setAddress(&quot;redis://localhost:6379&quot;).setDatabase(0);</span></span>
<span class="line"><span>        return (Redisson) Redisson.create(config);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span></code></pre></div><h4 id="加锁和释放" tabindex="-1">加锁和释放 <a class="header-anchor" href="#加锁和释放" aria-label="Permalink to &quot;加锁和释放&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    @Autowired</span></span>
<span class="line"><span>    Redisson redisson;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @GetMapping(&quot;/buy3&quot;)</span></span>
<span class="line"><span>    public String buy3() {</span></span>
<span class="line"><span>        String lockKey = &quot;product_01&quot;;</span></span>
<span class="line"><span>        RLock lock = redisson.getLock(lockKey);</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            lock.lock();//真正的加锁 setIfAbsent 30s</span></span>
<span class="line"><span>            Integer i = Integer.parseInt(redisUtils.get(&quot;stock&quot;).toString());</span></span>
<span class="line"><span>            if (i &gt; 0) {</span></span>
<span class="line"><span>                int real = i - 1;</span></span>
<span class="line"><span>                redisUtils.set(&quot;stock&quot;, real + &quot;&quot;);</span></span>
<span class="line"><span>                logger.info(&quot;购买成功,剩余:&quot; + real);</span></span>
<span class="line"><span>            } else {</span></span>
<span class="line"><span>                logger.info(&quot;购买失败&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            lock.unlock();//</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return &quot;buy end&quot;;</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>redisson大致逻辑(lua脚本实现):</p><ol><li>线程1加锁成功(30s), 开启后台线程(每个10s检测线程1是否还持有锁,如果有则延长10s)</li><li>线程2判断是否能加锁,不能则自旋等待,知道能为止</li><li>线程1释放锁,线程2加锁</li></ol><h3 id="redis主从架构导致的分布式锁失效问题" tabindex="-1">Redis主从架构导致的分布式锁失效问题 <a class="header-anchor" href="#redis主从架构导致的分布式锁失效问题" aria-label="Permalink to &quot;Redis主从架构导致的分布式锁失效问题&quot;">​</a></h3><p>客户端加锁拿到主节点的返回后,主节点还未同步给从节点就宕机了,导致从节点没有拿到客户端的锁.</p><blockquote><p>CAP原则:一致性/可用性/分区容错性,三者不可能同时存在.</p></blockquote><ul><li>Redis满足AP:一致性/分区容错性,Redis强调可用性,会立即返回结果.</li><li>Zookeeper满足CP:一致性/分区容错性,同样的,Zookeeper在客户端加锁后不会立即返回结果, 只有Zookeeper集群半数以上都获得同步后,才会返回客户端成功(过半写)</li></ul><h4 id="redlock" tabindex="-1">Redlock <a class="header-anchor" href="#redlock" aria-label="Permalink to &quot;Redlock&quot;">​</a></h4><p>Redis对于此问题,也可以使用Redlock来解决. Redlock针对的是客户端,客户端加锁后,超过半数以上的节点加锁成功才算成功.( 牺牲可用性,不如直接用zookeeper)</p>`,113)]))}const m=n(l,[["render",i]]);export{h as __pageData,m as default};
